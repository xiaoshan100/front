<!--
 * @Author: DESKTOP-HMVTUKK\Administrator cssor@foxmail.com
 * @Date: 2024-05-05 12:08:46
 * @LastEditors: DESKTOP-HMVTUKK\Administrator cssor@foxmail.com
 * @LastEditTime: 2024-05-05 14:39:01
 * @FilePath: \other\js\index.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

#### 发布订阅模式和观察者模式有什么区别

> 观察者模式（Observer Pattern）

- 直接依赖：在观察者模式中，观察者（Observers）直接订阅主题（Subject），形成了更紧密的耦合关系。观察者知道并且直接依赖于被观察的对象。
- 通知方式：当主题状态发生变化时，它会直接通知所有注册的观察者。这种通知通常是通过调用观察者上的一个方法（如 update()）来实现的，这意味着主题需要维护所有观察者的引用。
- 传统的观察者模式倾向于同步通知，即所有观察者在主题状态变化后立即被通知并执行更新操作，这可能导致性能问题或顺序执行的依赖。
- 缺点：观察者模式需要维护一个观察者列表，当观察者数量 Many 时，会增加内存消耗和性能问题。

> 发布订阅模式（Publish/Subscribe Pattern）

- 间接通信：发布订阅模式引入了一个中间层（通常称为“事件总线”、“消息队列”或“事件处理器”），发布者（Publishers）发布事件到这个中间层，而订阅者（Subscribers）则订阅这些事件。发布者和订阅者不直接知道对方的存在，降低了耦合度。
- 解耦：由于存在中间件，发布者和订阅者之间是完全解耦的。每个实体仅与中间件交互，这提供了更高的灵活性和可扩展性。
- 异步处理：发布订阅模式天然支持异步处理，事件可以被异步地发布和接收，允许系统在处理其他任务的同时处理事件，提高了系统的响应性和并发处理能力。
- 动态订阅：订阅者可以在任何时刻加入或退出订阅，不需要事先知道发布者，也不影响发布者的逻辑。

> 尽管两者都用于实现对象之间的解耦通信，发布订阅模式通过引入中间层进一步增强了系统的松耦合性和灵活性。观察者模式更适用于简单的场景，而发布订阅模式更适合需要高度解耦、异步处理和动态管理订阅关系的复杂系统。在某些情况下，发布订阅模式被视为观察者模式的一个进化或扩展版本。

#### nextTick 的作用是什么 底层的实现原理是什么

#### 封装第三方组件的时候 如何透传属性和方法

- 在 react 中，一般属性与事件的透传可以用直接展开即开开运算符`...`来传递，方法的透传，一般可以通过`refs`,如果第三方组件暴露了需要调用的方法，可以通过创建 refs 并访问这些方法

#### 首屏的 ssr

#### 节流和防抖的实现

#### 哪些对象有...（扩展运算符）

> 对象、数组，一般可以用在数组或者对象的合并，构造新对象、解构赋值、函数传参里使用，一般 Array、Set、Map、生成器（Generator）等都是可迭代的，都可以使用

#### 什么是可迭代对象

> 可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 `for..of`循环中使用的对象。
> 可以应用 for..of 的对象被称为 可迭代的。

> 技术上来说，可迭代对象必须实现 Symbol.iterator 方法。
> `obj[Symbol.iterator]()` 的结果被称为 迭代器（iterator）。由它处理进一步的迭代过程。
> 一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。
> Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。
> 内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。
> 字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）
> 有索引属性和 length 属性的对象被称为 类数组对象。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。

> 如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。

> `Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 obj 转化为真正的数组 Array，然后我们就可以对它应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。

#### 函数柯里化是什么，有哪些应用场景

#### defer、DOMcontentLoaded（onReady）、onload 的差异

> 浏览器加载步骤

- 解析 html 结构
- 加载外部 js 脚本和样式表文件（预扫描）
- 解析并执行 js 脚本
- dom 树构建完成 - html 解析完毕（如果有 defer 就解析）（完成后触发 onReady->即 DOMcontentLoaded）;
- 加载图片等外部文件（完成后触发图片 onload）
- 页面加载完毕（完成后出发页面 onload）

|          |                DOMcontentLoaded                |                                        onload |
| :------- | :--------------------------------------------: | --------------------------------------------: |
| 执行时机 |             在 html 解析完毕后执行             | 在页面所有元素（包括图片+页面）加载完成后执行 |
| 执行次数 | onReady 可以执行多个，并且都可以按顺序得到执行 |                                只执行最后一个 |
